# Part of XYalign
# Functions for calling and processing variants

from __future__ import division
import subprocess
import pysam
import bam
# Matplotlib needs to be called in this way to set the display variable
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt


def platypus_caller(
	platypus_path, log_path, bam, ref, chroms, cpus, output_file,
	regions_file=None):
	"""
	Uses platypus to make variant calls on provided bam file

	platypus_path is the path to platypus
	log_path is the path to and name of desired log file for platypus
	bam is input bam (or cram) file
	ref is path to reference sequence
	chroms is a list of chromosomes to call on, e.g., ["chrX", "chrY", "chr19"]
	cpus is the number of threads/cores to use
	output_file is the name of the output vcf
	regions_file (default none) - if not none, will only make calls in regions
		included in this BED file (note: must be in bed format)

	Outputs a vcf, but returns the exit code of the Platypus call
	"""
	if regions_file is None:
		regions = ','.join(map(str, chroms))
	else:
		regions = regions_file
	return_code = subprocess.call(
		[platypus_path, "callVariants", "--bamFiles", bam, "-o", output_file,
			"--refFile", ref, "--nCPU", str(cpus), "--regions", regions,
			"--assemble", "1", "--logFileName", log_path])
	return return_code


def parse_platypus_VCF(filename, qual_cutoff, chrom):
	"""
	Parse vcf generated by Platypus to grab read balance

	filename is the full path to the input vcf
	qual_cutoff the minimum (PHRED) quality at which sites should be included
	chrom is the name of the chromosome to include

	Returns:
		Tuple containing three corresponding arrays of the same length:
			position across the chromosome
			site quality
			read balance
	"""
	infile = open("{}".format(filename), 'r')
	positions = []
	quality = []
	readBalance = []
	for line in infile:
		cols = line.strip('\n').split('\t')
		if cols[0] != chrom:
			continue
		pos = int(cols[1])
		qual = float(cols[5])
		if qual < qual_cutoff:
			continue
		TR = cols[7].split(';')[17].split('=')[1]
		TC = cols[7].split(';')[14].split('=')[1]
		if ',' in TR or ',' in TC:
			continue
		if (float(TR) == 0) or (float(TC) == 0):
			continue
		ReadRatio = float(TR) / float(TC)

		# Add to arrays
		readBalance.append(ReadRatio)
		positions.append(pos)
		quality.append(qual)

	return (positions, quality, readBalance)


def plot_variants_per_chrom(
	chrom_list, vcf_file, sampleID, output_prefix, qual_cutoff,
	MarkerSize, MarkerAlpha, bamfile):
	"""
	Parses a vcf file and plots read balance in separate plots
	for each chromosome in the input list

	chrom_list is the list of chromosomes to run parse_platypus_VCF and plotting
		functions on
	vcf_file is the file (including path) of platypus vcf to analyze
	sampleID is the sample name (for plot titles)
	output_prefix is the full path to and prefix of desired output plots
	qual_cutoff is the minimum (Phred) quality to consider a site in the vcf
	MarkerSize is the size of markers (matplotlib sizes) to use in the figure
	MarkerAlpha is the transparency (matplotlib values) of markers for the figure
	bamfile is the name of the corresponding bam file (used to get chromosome
		lengths only)

	Returns:
		Nothing
	"""
	for i in chrom_list:
		parse_results = parse_platypus_VCF(vcf_file, qual_cutoff, i)
		plot_read_balance(
			i, parse_results[0], parse_results[2],
			sampleID, output_prefix, MarkerSize, MarkerAlpha, bamfile)
		hist_read_balance(
			i, parse_results[2], sampleID, output_prefix)
	pass


def plot_read_balance(
	chrom, positions, readBalance, sampleID, output_prefix, MarkerSize,
	MarkerAlpha, bamfile):
	"""
	Plots read balance at each SNP along a chromosome

	chrom is the name of the chromosome
	positions is an array of positions along the chromosome (same length as
		readBalance)
	readBalance is an array of read balance corresponding with the positions
		in the positions array
	sampleID is the sample name or id to include in the plot title
	output_prefix is the desired prefix (including full path) of the output files
	MarkerSize is the size of markers (matplotlib sizes) to use in the figure
	MarkerAlpha is the transparency (matplotlib values) of markers for the figure
	bamfile is the name of the corresponding bam file (used to get chromosome
		lengths only)

	Outputs:
		Scatter (along genomic positions) plot of read balance values
	Returns:
		Nothing
	"""
	if bamfile[-3] == "bam" or bamfile[-3] == "BAM":
		chrom_len = bam.get_length(pysam.AlignmentFile(bamfile, "rb"), chrom)
	else:
		chrom_len = bam.get_length(pysam.AlignmentFile(bamfile, "rc"), chrom)
	if "x" in chrom.lower():
		Color = "green"
	elif "y" in chrom.lower():
		Color = "blue"
	else:
		Color = "red"
	fig = plt.figure(figsize=(15, 5))
	axes = fig.add_subplot(111)
	axes.scatter(
		positions, readBalance, c=Color, alpha=MarkerAlpha, s=MarkerSize, lw=0)
	axes.set_xlim(0, chrom_len)
	axes.set_title(sampleID)
	axes.set_xlabel("Chromosomal Coordinate")
	axes.set_ylabel("Read Balance")
	# print(len(positions))
	plt.savefig("{}_{}_ReadBalance_GenomicScatter.svg".format(
		output_prefix, chrom))
	plt.savefig("{}_{}_ReadBalance_GenomicScatter.png".format(
		output_prefix, chrom))
	plt.close(fig)


def hist_read_balance(chrom, readBalance, sampleID, output_prefix):
	"""
	Plots a histogram of read balance

	chrom is the name of the chromosome
	readBalance is an array of read balance values
	sampleID is the sample name or id to include in the plot title
	output_prefix is the desired prefix (including full path) of the output files

	Outputs:
		Histogram plot of read balance values
	Returns:
		Nothing
	"""
	read_balance = readBalance[0.05 < readBalance < 0.95]
	if "x" in chrom.lower():
		Color = "green"
	elif "y" in chrom.lower():
		Color = "blue"
	else:
		Color = "red"
	fig = plt.figure(figsize=(8, 8))
	axes = fig.add_subplot(111)
	axes.set_title(sampleID)
	axes.set_xlabel("Read Balance")
	axes.set_ylabel("Frequency")
	axes.hist(readBalance, bins=50, color=Color)
	plt.savefig("{}_{}_ReadBalance_Hist.svg".format(output_prefix, chrom))
	plt.savefig("{}_{}_ReadBalance_Hist.png".format(output_prefix, chrom))
	plt.close(fig)
